{"version":3,"sources":["../src/monitor.ts"],"names":[],"mappings":"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","file":"monitor.js","sourcesContent":["\nimport { Constants } from 'jdbcsql_throughput';\nconst assert = require('assert');\n\nimport * as debug from 'debug';\nconst debuglog = debug('monitor');\n\nvar cnt = 0;\n\n//export var MONITOR_SYSTABLE_NAME = \"SYS.INTERNAL_REL_NODE_RT_AVG;\";\n\nexport var MONITOR_SYSTABLE_NAME = \"SYS.INTERNAL_REL_NODE_RUNTIME_AVG;\";\n\n//var monitor_statement = 'SELECT * FROM SYS.INTERNAL_REL_NODE_RT_AVG;';\n\n\nimport { IRecord } from './dbconnector';\n\nexport interface IResult {\n  TAG: string,\n  QPM : number,\n  BAD : number,\n  PAR : number,\n  DUR : number,\n  DDP : number,\n  MAXMEM : number,\n  CPU : number,\n  MEM : number,\n  MEU : number,\n  PAR_N : number,\n  QPM_N : number,\n  DUR_N : number\n  };\n  export class IAvgRecord {\n    MAX_MEM_USAGE_30s : number = 0;\n    MEM_USAGE : number = 0;\n    AGGR_PLAN_EXEC_DURATION : number = 0;\n    QUERY_PER_MIN : number = 0;\n    CPU_UTILIZATION : number = 0;\n    MEM_UTILIZATION : number = 0;\n    MAX_MEM_EVER : number = 0;\n    NR_PARALLEL_PLAN : number = 0;\n    PLAN_EXEC_DURATION : number = 0;\n    constructor() {}\n  };\n\n  export const Keys = Array.from(Object.keys(new IAvgRecord()));\n\n\n\n  export function dumpNice(v : any, len : number) {\n    var s = '' + v;\n    while(s.length < len) {\n      s = ' ' + s;\n    }\n    return s;\n  }\n\n\n\nexport class Monitor {\n  constructor(parexec : Constants.IParallelExecutor) {\n    this.para_exec = parexec;\n  }\n  para_exec : Constants.IParallelExecutor;\n\n  stopMonitor() {\n    this.para_exec.stopOp('monitor');\n  }\n\n  startMonitor() {\n    var that = this;\n    this.para_exec.startOpRepeat(\n      \"monitor\",\n      'SELECT * FROM ' + MONITOR_SYSTABLE_NAME + ';',\n      4,\n      {\n        forcename : \"monitor\",\n        continuous : true,\n        t_last : 0,\n        every_t : 3000, // every second!\n      },\n      /*callbacks :*/\n      {\n        result : function(err, res) {\n          if(!err) {\n            var timing = that.updateAverages(res);\n          }\n        }\n      }\n    )\n  };\n\n  lastRecord : IRecord = {\n    time : Date.now(),\n    QPS : 0,\n    PAR : 0,\n    CPU : 0,\n    DUR : 0,\n    MEM : 0,\n    MAXMEM : 0,\n    FAIL : 0,\n    NP : 0\n  }\n\n  updateAverages(res : any) {\n    var rec = this.makeTimingRecord(res);\n    var avg = this.getBestSingleAvg(rec);\n    this.lastRecord = this.toRecord(avg);\n    this.lastRecord.time = Date.now();\n  }\n\n  getLastRecord() : IRecord {\n    return this.lastRecord;\n  }\n\n  makeTimingRecord(res : any) : Constants.ITimingMap {\n  var result : Constants.ITimingMap = new Map<string, Map<number, number> >();\n  Keys.forEach(key => {\n    res.forEach( rec => {\n      if (rec.NAME == key) {\n        debuglog.enabled && debuglog( ' found record ' + rec.VALUE + \" \" + JSON.stringify(rec));\n        if(!result.has(key)) {\n          result.set(key, new Map<number,number>());\n        }\n        var mp = result.get(key);\n        mp.set(parseInt(rec.NR), parseInt(rec.VALUE));\n      }\n    });\n  });\n  return result;\n}\n\n  getBestSingleAvg(record : Constants.ITimingMap) : IAvgRecord\n  {\n    var  values = new IAvgRecord();\n    const best_avg = 3001; // 3s\n    var actual_best_avg = 0;\n      debuglog('got a best record!!');\n      Keys.forEach(key => {\n      var rec = record.get(key);\n      var sortedIntArr = Array.from(rec.keys()).map(k => parseInt(' ' + k)).sort();\n      debuglog('sortedIntArr' + sortedIntArr);\n      values[key] = sortedIntArr.reduce((prev, time) =>\n         {\n           if((time < best_avg))\n           {\n             actual_best_avg = time;\n             return rec.get(time);\n           } else {\n             return prev;\n            }\n          }\n         , 0);\n        });\n    assert(actual_best_avg == 3000);\n    return values;\n  }\n\n  toRecord(values : IAvgRecord): IRecord {\n    debuglog.enabled && debuglog(\"******* DONE \");\n    var avgx : any = values;\n    debuglog.enabled && debuglog( 'QPM\\t|BAD%\\t|PAR'\n            + '\\t|DUR'\n            + '\\t|DDP'\n            + '\\t|MAX_MEM'\n            + '\\t|CPU%'\n            + '\\t|MEM%'\n            + '\\t|MEU'\n            + '\\t|QPM_N'\n            + '\\t|PAR_P'\n            + '\\t|AGGR_PLAN_EXEC_DURATION'\n            )\n    var result : IRecord = {\n      time : Date.now(),\n      QPS : 0,\n      FAIL : 0,\n      PAR : avgx.NR_PARALLEL_PLAN,\n      DUR : avgx.AGGR_PLAN_EXEC_DURATION,\n      MAXMEM : avgx.MAX_MEM_EVER ,\n      CPU :  avgx.CPU_UTILIZATION,\n      MEM : avgx.MEM_UTILIZATION,\n      NP :  avgx.NR_PARALLEL_PLAN\n    };\n    this.dumpAllResults([result]);\n    debuglog.enabled && debuglog( result.time +\n         + '\\t|' + result.QPS\n         + '\\t|' + result.FAIL\n         + '\\t|' + result.DUR,\n         + '\\t|' + result.NP\n         + '\\t|' + avgx.MAX_MEM_EVER\n         + '   \\t|' + avgx.CPU_UTILIZATION\n         + '\\t|' + result.MEM,\n         + '\\t|' + avgx.NR_PARALLEL_PLAN\n         + '\\t|' + avgx.QUERY_PER_MIN\n         + '\\t|' + avgx.AGGR_PLAN_EXEC_DURATION\n    );\n    return result;\n  }\n\n    //var handle = runner.startOpRepeat('SELECT COUNT(*) FROM T1;', 20);\n    //QPM     |BAD%   |PAR    |NR_PARALLEL_PLAN       |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n    //10      |0      |4      |4      |165    |94     |173    |169    |2624\n    //QPM     |BAD%   |PAR    |PAR_P  |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n    //10      |0      |8      |4      |174    |98     |171    |1      |2761\n\n  dumpAllResults(allresult : IRecord[]) {\n    if(allresult.length == 0) {\n      return;\n    }\n    var s1 = Object.keys(allresult[0]).map( key => dumpNice(key,10)).join(\",\");\n    debuglog.enabled && debuglog(s1);\n    allresult.forEach(entry =>\n    {\n      var sn =  Object.keys(entry).map( key => dumpNice(entry[key],10)).join(',');\n      debuglog.enabled && debuglog(sn);\n    });\n  }\n}; // class\n\n\n/*\nexport function registerTiming( time : number, rec : ITimingMap)\n{\n  handles.forEach(function(op) {\n    if(op.status != Status.STOPPED)\n    {\n      op.timings.push({ time : time, rec : rec});\n      //console.log( 'timing length now' + op.timings.length);\n    }\n  });\n}\n\nexport function getBestTime(start : number, end : number )\n{\n  return start + (end - start)*0.8;\n}\n\nexport function getAvgLength( start : number, end : number )\n{\n  return (end-start) * 0.2;\n}\n\nexport class IAvgRecord {\n  MAX_MEM_USAGE_30s : number = 0;\n  MEM_USAGE : number = 0;\n  AGGR_PLAN_EXEC_DURATION : number = 0;\n  QUERY_PER_MIN : number = 0;\n  CPU_UTILIZATION : number = 0;\n  MEM_UTILIZATION : number = 0;\n  MAX_MEM_EVER : number = 0;\n  NR_PARALLEL_PLAN : number = 0;\n  PLAN_EXEC_DURATION : number = 0;\n  constructor() {}\n};\n\nexport class IAvgSet {\n  time : number = 0;\n  avg : number = 0;\n  values : IAvgRecord = new IAvgRecord();\n};\n\nexport const Keys = Array.from(Object.keys(new IAvgRecord()));\nexport function getBestAvg(start : number,  recs :  ITimingRec[]) : IAvgSet\n{\n  // find the maximum of ITimingRec[]\n  //recs.forEach(entry => console.log(' time is ' + entry.time ))\n  const end_time = recs.reduce( (prev,current) => (current.time > prev)? current.time: prev , 0);\n  const best_time = getBestTime(start, end_time);\n  debuglog( 'start' + (start - t_total) + ' end' + (end_time - t_total) + ' best' + ( best_time - t_total) );\n  if( recs.length < 3)\n  {\n    console.log(\"warning, timing length low\" + recs.length);\n  }\n  recs.forEach(rec =>\n    debuglog('at ' + (rec.time - t_total)));\n  const bestTimingRec = recs.reduce( (prev, current) =>  (!prev || (current.time < best_time)) ? current : prev , undefined);\n  var result : IAvgSet =\n  {\n    time : 0,\n    avg : 0,\n    values : new IAvgRecord\n  };\n  const best_avg = getAvgLength(start, end_time);\n  debuglog('best avg length ' + best_avg);\n  var actual_best_avg = 0;\n  if ( bestTimingRec )\n  {\n    debuglog('got a best record!!');\n    Keys.forEach(key => {\n    var rec = bestTimingRec.rec.get(key);\n    var sortedIntArr = Array.from(rec.keys()).map(k => parseInt(' ' + k)).sort();\n    debuglog('sortedIntArr' + sortedIntArr);\n    result.values[key] = sortedIntArr.reduce((prev, time) =>\n       {\n         if((time < best_avg))\n         {\n           actual_best_avg = time;\n           return rec.get(time);\n         } else {\n           return prev;\n          }\n        }\n       , 0);\n      });\n    }\n  debuglog('best avg' + actual_best_avg);\n  result.avg = actual_best_avg;\n  result.time = bestTimingRec && bestTimingRec.time;\n  return result;\n}\n\nexport function dumpNice(v : any, len : number) {\n  var s = '' + v;\n  while(s.length < len) {\n    s = ' ' + s;\n  }\n  return s;\n}\n\n\n\n\nexport function startSequence(configFileName : string, testpool: Pool, current_index = 0) {\n\n  //var tcp001 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'FOB\\' AND T1.L_QUANTITY > 2 AND T2.L_QUANTITY > 10 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n  //var tcp001 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'B\\' AND T1.L_QUANTITY > 10 AND T2.L_QUANTITY > 10 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n  //var tcp001 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'B\\' AND T1.L_QUANTITY > 10 AND T2.L_QUANTITY > 100 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n  var tcp_001_4 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'FOB\\' AND T1.L_PARTKEY > 1000 AND T2.L_PARTKEY > 1000 AND T1.L_QUANTITY > 2 AND T2.L_QUANTITY > 10 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n  var parq_1m_zip = 'select max(VCHAR50RNDVL), vchar4dic6, avg(UINT64_RND) from GEN_1M_PAR_ZIP group by VCHAR4DIC6;';\n\n  //ALTERD\n  //tcp_001_4 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'FOB\\' AND T1.L_PARTKEY > 1000 AND T2.L_PARTKEY > 1000 AND T1.L_QUANTITY > 2 AND T2.L_QUANTITY > 1000 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n\n  var arr = [\n    { PAR : 1,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR : 2,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n  // { PAR : 3,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR : 4,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n  // { PAR : 6,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR : 8,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n  //  { PAR :10,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :12,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :16,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :20,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :32,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'}\n  ];\n  arr.forEach( entry => entry['TAG'] = 'TCP_P_' + entry.PAR );\n  arr.forEach( entry => entry['TAG'] = 'P1Z_P_' + entry.PAR );\n  arr.forEach( entry => entry['statement'] = tcp_001_4 );\n  arr.forEach( entry => entry['statement'] = parq_1m_zip );\n  arr.forEach( entry => entry['MAX_NR'] = 40 );\n\n\n  if (current_index == 0) {\n    // create the forks!\n    var max_parallel = arr.reduce(  (prev, entry) => Math.max(prev, entry.PAR), 0 );\n    var nrForks = Math.ceil(max_parallel / 4);\n    forks = new Forks(nrForks , configFileName);\n    ;\n  }\n  var hndl = startOpMonitor(parexec);\n\n  var executors : ISQLExecutor[];\n  executors = SQLExec.getExecutors(testpool,4);\n  executors = executors.concat(forks.getExecutors(4));\n  parexec = new ParallelExec(executors);\n  //var handle = runner.startOpRepeat('SELECT COUNT(*) FROM T1;', 20);\n  //QPM     |BAD%   |PAR    |NR_PARALLEL_PLAN       |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |4      |4      |165    |94     |173    |169    |2624\n  //QPM     |BAD%   |PAR    |PAR_P  |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |8      |4      |174    |98     |171    |1      |2761\n\n  var showOp = dumpProgress;\n  var makeNext = function (op)  {\n    var res = dumpDone(op);\n    allresults.push(res);\n    dumpAllResults(allresults);\n    parexec.stopOp('monitor');\n    parexec.stopOp(handle);\n    parexec.triggerLoop();\n    //loopIt(executor);\n    ++index;\n    if(index < arr.length) {\n      console.log(\"*** INDEX\");\n      startSequence(configFileName, testpool, index);\n    } else {\n      forks.stop();\n    }\n  };\n\n  handle = parexec.startOpRepeat( arr[current_index].TAG, arr[current_index].statement, arr[current_index].PAR, {continuous : true,  terminate_nr : arr[current_index].MAX_NR },\n    {\n      progress : showOp,\n      done : makeNext\n    });\n\n  parexec.triggerLoop();\n  var handle;\n  setTimeout( function() {\n  }, 500);\n\n  // beware, this only stops when all queries are completed;\n  /*\n  setTimeout( function() {\n    console.log('stopping now');\n    stopOp(handle);\n    loopIt(executor);\n  }, 200000);\n  */\n"],"sourceRoot":"."}